<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Valentine Flower Reveal</title>
  <style>
    :root {
      --title: #8f2144;
      --message: #bb1f59;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 650px at 50% -10%, rgba(255, 210, 230, 0.45), transparent 65%),
        linear-gradient(#fffefc, #fff7f9 58%, #fffdf8);
      color: #1f1f1f;
    }

    .rose-3d {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }

    .quiz {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: auto;
      background: radial-gradient(circle at 50% 45%, rgba(255, 247, 252, 0.9), rgba(255, 240, 247, 0.7));
      transition: opacity 360ms ease, visibility 360ms ease;
    }

    .quiz.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .quiz-card {
      width: min(92vw, 560px);
      padding: 28px 22px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 16px 40px rgba(129, 35, 67, 0.18);
      text-align: center;
      border: 1px solid rgba(237, 187, 209, 0.7);
    }

    .quiz-card p {
      margin: 0 0 16px;
      font-size: clamp(1.1rem, 2.8vw, 1.5rem);
      font-weight: 700;
      color: #8f2144;
    }

    .quiz-buttons {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .quiz-btn {
      border: 0;
      border-radius: 999px;
      padding: 10px 20px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 150ms ease, filter 150ms ease, opacity 240ms ease;
    }

    .quiz-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.04);
    }

    .quiz-btn.no {
      background: linear-gradient(140deg, #df3d76, #be2259);
      color: #fff;
    }

    .quiz-btn.yes {
      background: linear-gradient(140deg, #ffe7f0, #ffd5e6);
      color: #8f2144;
    }

    .quiz-btn.yes.gone {
      opacity: 0;
      transform: scale(0.55);
      pointer-events: none;
    }

    h1 {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      width: min(92vw, 900px);
      text-align: center;
      font-size: clamp(1.08rem, 2.5vw, 1.8rem);
      line-height: 1.35;
      letter-spacing: 0.01em;
      color: var(--title);
      text-shadow: 0 2px 10px rgba(143, 33, 68, 0.14);
      transition: opacity 420ms ease, transform 420ms ease;
    }

    h1.hide {
      opacity: 0;
      transform: translateX(-50%) translateY(-14px);
    }

    .hidden-message {
      position: absolute;
      left: 50%;
      top: 18%;
      width: min(95vw, 980px);
      text-align: center;
      transform: translateX(-50%) translateY(8px) scale(0.92);
      font-size: clamp(1.4rem, 4vw, 2.9rem);
      font-weight: 800;
      color: var(--message);
      opacity: 0;
      letter-spacing: 0.02em;
      text-shadow: 0 4px 16px rgba(187, 31, 89, 0.22);
      transition: opacity 700ms ease, transform 700ms ease;
    }

    .hidden-message.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-6px) scale(1);
      animation: floatMessage 3.2s ease-in-out infinite;
    }

    .credit {
      position: absolute;
      right: 18px;
      bottom: 12px;
      font-size: clamp(0.9rem, 1.8vw, 1rem);
      color: rgba(120, 31, 59, 0.92);
      text-shadow: 0 2px 7px rgba(255, 255, 255, 0.9);
      letter-spacing: 0.01em;
    }

    @keyframes floatMessage {
      0%, 100% { transform: translateX(-50%) translateY(-6px) scale(1); }
      50% { transform: translateX(-50%) translateY(-20px) scale(1.02); }
    }

    @media (max-width: 680px) {
      .hidden-message { top: 20%; font-size: clamp(1.2rem, 6.2vw, 2.1rem); }
      .credit { right: 12px; bottom: 10px; }
    }
  </style>
</head>
<body>
  <canvas class="rose-3d" id="roseCanvas" aria-hidden="true"></canvas>

  <div class="overlay">
    <div class="quiz" id="quizGate">
      <div class="quiz-card">
        <p>Did you receive a rose today?</p>
        <div class="quiz-buttons">
          <button class="quiz-btn yes" id="yesBtn" type="button">Yes</button>
          <button class="quiz-btn no" id="noBtn" type="button">No</button>
        </div>
      </div>
    </div>
    <h1 id="instructionTitle">Click anywhere to drop one petal and reveal the hidden Valentine message.</h1>
    <div class="hidden-message" id="hiddenMessage">Valentine&apos;s day is to be celebrated.<br>Happy valentine!! :) </div>
    <div class="credit">Made by Harman</div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

    const roseCanvas = document.getElementById('roseCanvas');
    const hiddenMessage = document.getElementById('hiddenMessage');
    const instructionTitle = document.getElementById('instructionTitle');
    const quizGate = document.getElementById('quizGate');
    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');

    const petalCount = 18;
    let droppedCount = 0;
    let revealed = false;
    let started = false;
    let revealStartTime = 0;
    const revealDuration = 2.2;
    const heroBaseScale = 1.55;

    const renderer = new THREE.WebGLRenderer({ canvas: roseCanvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.06;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xfff3f8, 8, 24);

    const camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 70);
    camera.position.set(0, 2.65, 8.3);
    camera.lookAt(0, 1.55, 0);

    const hemi = new THREE.HemisphereLight(0xfff8fc, 0xf6d1df, 0.76);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xfff0f8, 1.18);
    key.position.set(4.6, 7.3, 5.4);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 0.6;
    key.shadow.camera.far = 28;
    key.shadow.camera.left = -8;
    key.shadow.camera.right = 8;
    key.shadow.camera.top = 8;
    key.shadow.camera.bottom = -8;
    scene.add(key);

    const rim = new THREE.DirectionalLight(0xffd3e4, 0.52);
    rim.position.set(-6, 4, -4.5);
    scene.add(rim);

    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(13, 96),
      new THREE.MeshStandardMaterial({ color: 0xfff1f6, roughness: 0.93, metalness: 0.01 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.02;
    ground.receiveShadow = true;
    scene.add(ground);

    function createPetalGeometry() {
      const geometry = new THREE.PlaneGeometry(0.36, 0.56, 22, 28);
      const pos = geometry.attributes.position;

      for (let i = 0; i < pos.count; i += 1) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const xNorm = x / 0.18;
        const yNorm = (y + 0.28) / 0.56;

        const cup = -Math.pow(Math.abs(xNorm), 1.8) * 0.06;
        const lift = Math.sin(yNorm * Math.PI) * 0.07;
        const tipCurl = Math.pow(yNorm, 2.2) * 0.06;
        const edgeTwist = xNorm * Math.pow(yNorm, 2) * 0.018;

        pos.setZ(i, cup + lift + tipCurl);
        pos.setX(i, x + edgeTwist);
      }

      geometry.computeVertexNormals();
      return geometry;
    }

    function createLeafGeometry() {
      const geometry = new THREE.PlaneGeometry(0.34, 0.2, 12, 10);
      const pos = geometry.attributes.position;

      for (let i = 0; i < pos.count; i += 1) {
        const xNorm = pos.getX(i) / 0.17;
        const yNorm = (pos.getY(i) + 0.1) / 0.2;
        const ridge = (1 - Math.abs(xNorm)) * 0.03;
        const curl = Math.sin(yNorm * Math.PI) * 0.02;
        pos.setZ(i, ridge + curl);
      }

      geometry.computeVertexNormals();
      return geometry;
    }

    const petalGeometry = createPetalGeometry();
    const leafGeometry = createLeafGeometry();

    function createHeroRose() {
      const rose = new THREE.Group();
      rose.position.set(0, 0, 0);

      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.045, 1.62, 12),
        new THREE.MeshStandardMaterial({ color: 0x467f49, roughness: 0.76, metalness: 0.02 })
      );
      stem.position.y = 0.78;
      stem.castShadow = true;
      rose.add(stem);

      const head = new THREE.Group();
      head.position.y = 1.62;
      rose.add(head);

      const innerMat = new THREE.MeshPhysicalMaterial({
        color: 0xb21f54,
        roughness: 0.43,
        metalness: 0.02,
        clearcoat: 0.42,
        clearcoatRoughness: 0.72,
        side: THREE.DoubleSide
      });

      const outerMat = new THREE.MeshPhysicalMaterial({
        color: 0xda2c68,
        roughness: 0.52,
        metalness: 0.01,
        clearcoat: 0.26,
        clearcoatRoughness: 0.8,
        side: THREE.DoubleSide
      });

      const bud = new THREE.Mesh(
        new THREE.SphereGeometry(0.11, 20, 20),
        new THREE.MeshStandardMaterial({
          color: 0xf0c44b,
          roughness: 0.5,
          metalness: 0.02
        })
      );
      bud.position.y = 0.07;
      bud.castShadow = true;
      head.add(bud);

      const detachablePetals = [];

      const rings = [
        { count: 6, radius: 0.08, rise: 0.03, tilt: 0.72, scale: 0.9, mat: innerMat, detachable: false },
        { count: 10, radius: 0.16, rise: 0.1, tilt: 0.92, scale: 1.02, mat: innerMat, detachable: true },
        { count: 14, radius: 0.25, rise: 0.16, tilt: 1.16, scale: 1.15, mat: outerMat, detachable: true }
      ];

      for (const ring of rings) {
        for (let i = 0; i < ring.count; i += 1) {
          const angle = (i / ring.count) * Math.PI * 2 + (Math.random() * 0.22 - 0.11);
          const petalMaterial = ring.mat.clone();
          petalMaterial.transparent = true;
          const petal = new THREE.Mesh(petalGeometry, petalMaterial);

          petal.position.set(
            Math.cos(angle) * ring.radius,
            ring.rise + (Math.random() * 0.02 - 0.01),
            Math.sin(angle) * ring.radius
          );
          petal.rotation.y = angle + Math.PI / 2;
          petal.rotation.x = ring.tilt + (Math.random() * 0.2 - 0.1);
          petal.rotation.z = (Math.random() * 0.24 - 0.12);
          const s = ring.scale + (Math.random() * 0.09 - 0.045);
          petal.scale.set(s, s, s);
          petal.castShadow = true;
          petal.receiveShadow = true;
          head.add(petal);

          if (ring.detachable) {
            detachablePetals.push(petal);
          }
        }
      }

      // Keep exactly `petalCount` detachable petals.
      while (detachablePetals.length > petalCount) {
        const extra = detachablePetals.pop();
        extra.parent.remove(extra);
      }

      const leafMat = new THREE.MeshStandardMaterial({
        color: 0x3f8348,
        roughness: 0.71,
        metalness: 0.02,
        side: THREE.DoubleSide
      });

      for (let i = 0; i < 3; i += 1) {
        const leaf = new THREE.Mesh(leafGeometry, leafMat);
        const dir = i % 2 === 0 ? 1 : -1;
        leaf.position.set(dir * (0.17 + i * 0.02), 0.48 + i * 0.22, 0);
        leaf.rotation.y = dir * (1.02 + i * 0.18);
        leaf.rotation.x = -0.32 + i * 0.06;
        leaf.castShadow = true;
        rose.add(leaf);
      }

      rose.userData = { head, bud, detachablePetals };
      return rose;
    }

    function createFieldRose() {
      const rose = new THREE.Group();
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.034, 1.4, 12),
        new THREE.MeshStandardMaterial({ color: 0x47854c, roughness: 0.8, metalness: 0.02 })
      );
      stem.position.y = 0.7;
      stem.castShadow = true;
      rose.add(stem);

      const head = new THREE.Group();
      head.position.y = 1.38;
      rose.add(head);

      const hue = 0.94 + Math.random() * 0.035;
      const sat = 0.72 + Math.random() * 0.15;
      const lit = 0.42 + Math.random() * 0.08;

      const matA = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color().setHSL(hue, sat, lit - 0.05),
        roughness: 0.47,
        metalness: 0.02,
        clearcoat: 0.35,
        clearcoatRoughness: 0.72,
        side: THREE.DoubleSide
      });

      const matB = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color().setHSL(hue, sat - 0.05, lit + 0.03),
        roughness: 0.53,
        metalness: 0.01,
        clearcoat: 0.24,
        clearcoatRoughness: 0.8,
        side: THREE.DoubleSide
      });

      const rings = [
        { count: 7, radius: 0.08, rise: 0.02, tilt: 0.67, s: 0.82, mat: matA },
        { count: 11, radius: 0.14, rise: 0.08, tilt: 0.86, s: 0.95, mat: matA },
        { count: 15, radius: 0.2, rise: 0.12, tilt: 1.05, s: 1.08, mat: matB },
        { count: 18, radius: 0.27, rise: 0.16, tilt: 1.2, s: 1.22, mat: matB }
      ];

      for (const ring of rings) {
        for (let i = 0; i < ring.count; i += 1) {
          const p = new THREE.Mesh(petalGeometry, ring.mat);
          const angle = (i / ring.count) * Math.PI * 2 + (Math.random() * 0.2 - 0.1);
          p.position.set(Math.cos(angle) * ring.radius, ring.rise, Math.sin(angle) * ring.radius);
          p.rotation.y = angle + Math.PI / 2;
          p.rotation.x = ring.tilt + (Math.random() * 0.18 - 0.09);
          p.rotation.z = (Math.random() * 0.24 - 0.12);
          const s = ring.s + (Math.random() * 0.08 - 0.04);
          p.scale.set(s, s, s);
          p.castShadow = true;
          p.receiveShadow = true;
          head.add(p);
        }
      }

      const leafMat = new THREE.MeshStandardMaterial({ color: 0x3f8348, roughness: 0.72, metalness: 0.02, side: THREE.DoubleSide });
      for (let i = 0; i < 2; i += 1) {
        const leaf = new THREE.Mesh(leafGeometry, leafMat);
        const dir = i === 0 ? 1 : -1;
        leaf.position.set(dir * 0.16, 0.55 + i * 0.23, 0);
        leaf.rotation.y = dir * 1.05;
        leaf.rotation.x = -0.3;
        rose.add(leaf);
      }

      rose.userData.baseYaw = Math.random() * Math.PI * 2;
      rose.userData.swaySpeed = 0.34 + Math.random() * 0.48;
      rose.userData.swayAmt = 0.025 + Math.random() * 0.02;
      return rose;
    }

    const heroRose = createHeroRose();
    heroRose.scale.setScalar(heroBaseScale);
    scene.add(heroRose);

    const fieldGroup = new THREE.Group();
    fieldGroup.visible = false;
    scene.add(fieldGroup);

    const fieldCount = window.innerWidth < 640 ? 18 : 42;
    for (let i = 0; i < fieldCount; i += 1) {
      const r = createFieldRose();
      const radius = 2 + Math.pow(Math.random(), 0.72) * 6.2;
      const angle = Math.random() * Math.PI * 2;
      r.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
      const scale = 0.78 + Math.random() * 0.62;
      r.scale.set(scale, scale, scale);
      r.userData.startPos = r.position.clone();
      r.userData.startScale = scale;
      r.userData.startYaw = r.rotation.y;
      const bouquetSpread = window.innerWidth < 640 ? 0.8 : 1.2;
      const bouquetRadius = Math.pow(Math.random(), 0.62) * bouquetSpread;
      const bouquetAngle = (Math.random() * Math.PI * 0.85) - (Math.PI * 0.425);
      r.userData.bouquetPos = new THREE.Vector3(
        Math.sin(bouquetAngle) * bouquetRadius,
        0,
        0.7 + Math.cos(bouquetAngle) * bouquetRadius * 0.8
      );
      r.userData.bouquetScale = scale * (0.94 + Math.random() * 0.12);
      r.userData.bouquetYaw = Math.PI + (Math.random() * 0.45 - 0.225);
      fieldGroup.add(r);
    }

    const detachedPetals = [];

    function setGroupOpacity(group, alpha) {
      group.traverse((node) => {
        if (!node.isMesh) return;
        const mat = node.material;
        if (Array.isArray(mat)) return;
        mat.transparent = true;
        mat.opacity = alpha;
      });
    }

    setGroupOpacity(fieldGroup, 0);

    function dropNextPetal() {
      if (!started || revealed) return;

      const petals = heroRose.userData.detachablePetals;
      if (!petals.length) return;

      const petal = petals.pop();
      scene.attach(petal);

      const drift = new THREE.Vector3(
        (Math.random() * 0.017 - 0.0085),
        0.028 + Math.random() * 0.017,
        (Math.random() * 0.017 - 0.0085)
      );

      petal.userData.fall = {
        velocity: drift,
        spin: new THREE.Vector3(
          0.045 + Math.random() * 0.06,
          0.02 + Math.random() * 0.04,
          0.04 + Math.random() * 0.06
        ),
        age: 0,
        life: 2.2 + Math.random() * 1.4
      };

      detachedPetals.push(petal);
      droppedCount += 1;

      if (droppedCount >= petalCount) {
        reveal();
      }
    }

    function reveal() {
      revealed = true;
      revealStartTime = clock.getElapsedTime();
      instructionTitle.classList.add('hide');
      hiddenMessage.classList.add('show');
      heroRose.userData.bud.visible = false; // remove yellow bud
      fieldGroup.visible = true;
    }

    function vanishYesButton(event) {
      event.preventDefault();
      event.stopPropagation();
      yesBtn.classList.add('gone');
    }

    yesBtn.addEventListener('pointerenter', vanishYesButton);
    yesBtn.addEventListener('pointerdown', vanishYesButton);

    function startExperience(event) {
      event.preventDefault();
      event.stopPropagation();
      started = true;
      quizGate.classList.add('hidden');
    }

    noBtn.addEventListener('pointerdown', startExperience);

    window.addEventListener('pointerdown', (event) => {
      if (event.target.closest('#quizGate')) return;
      dropNextPetal();
    });

    const clock = new THREE.Clock();

    function animate() {
      const delta = clock.getDelta();
      const t = clock.getElapsedTime();

      if (heroRose.visible) {
        heroRose.rotation.z = Math.sin(t * 0.8) * 0.05;
        heroRose.rotation.y = Math.sin(t * 0.42) * 0.07;
      }

      for (let i = detachedPetals.length - 1; i >= 0; i -= 1) {
        const p = detachedPetals[i];
        const f = p.userData.fall;
        f.age += delta;

        f.velocity.y -= 0.00095;
        p.position.addScaledVector(f.velocity, 60 * delta);
        p.rotation.x += f.spin.x;
        p.rotation.y += f.spin.y;
        p.rotation.z += f.spin.z;

        const alpha = 1 - (f.age / f.life);
        p.material.opacity = Math.max(alpha, 0);

        if (f.age >= f.life || p.position.y < -0.4) {
          scene.remove(p);
          p.material.dispose();
          detachedPetals.splice(i, 1);
        }
      }

      if (revealed && heroRose.visible) {
        const progress = Math.min((t - revealStartTime) / revealDuration, 1);
        setGroupOpacity(fieldGroup, progress);
        setGroupOpacity(heroRose, 1 - progress);
        const scale = heroBaseScale * (1 - progress * 0.14);
        heroRose.scale.setScalar(scale);
        if (progress >= 1) {
          heroRose.visible = false;
        }
      }

      if (fieldGroup.visible) {
        const bouquetProgress = revealed
          ? Math.min(Math.max((t - revealStartTime - 0.45) / 2.6, 0), 1)
          : 0;
        for (const rose of fieldGroup.children) {
          if (bouquetProgress > 0) {
            rose.position.lerpVectors(rose.userData.startPos, rose.userData.bouquetPos, bouquetProgress);
            const s = THREE.MathUtils.lerp(rose.userData.startScale, rose.userData.bouquetScale, bouquetProgress);
            rose.scale.setScalar(s);
            rose.rotation.y = THREE.MathUtils.lerp(rose.userData.startYaw, rose.userData.bouquetYaw, bouquetProgress);
            rose.rotation.x = -0.16 * bouquetProgress;
          }
          rose.rotation.z = Math.sin(t * rose.userData.swaySpeed + rose.userData.baseYaw) * rose.userData.swayAmt;
          rose.rotation.y += 0.0006;
        }
      }

      camera.position.x = Math.sin(t * 0.11) * 0.44;
      camera.position.z = 8.3 + Math.cos(t * 0.11) * 0.27;
      camera.lookAt(0, 1.5, 0);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight, false);
    });
  </script>
</body>
</html>
